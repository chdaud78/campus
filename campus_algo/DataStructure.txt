# 자료구조
다수의 자료를 담기위한 구조
데이터 수가 많아질수록 효율적인 자료구조가 필요

1. 선형구조
* 배열
* 연결리스트
* 스택
* 큐
하나의 데이터 뒤에 다른 데이터가하나 존재하는 자료구조
데이터가 일렬로 연속적으로 연결

2. 비선형 구조
* 트리
* 그래프
하나의 데이터 뒤에 다른 데이터가 여러개 올 수 있는 자료구조
데이터가 일직선상으로 연결되어있지 않아도됨

# 프로그램 성능 측정 방법
시간 복잡도 : 알고리즘에 사용되는 연산 횟수를 측정
공간 복잡도 : 알고리즘에 사용되는 메모리의 양을 측정
복잡도는 Big-O 표기법을 사용
- 특정한 알고리즘이 얼마나 효율적인지 수치적으로 표현
- 가장 빠르게 증가하는 항만을 고려하는 표기법
- 강장 큰 항만을 표시 (계수는 제거)

# 배열
- 가장 기본적인 자료구조
- 여러 개의 변수를 담는 공간
- 인덱스가 존재, 0부터 시작
- 특정 인덱스에 직접적 접근 가능 -> 수행 시간 : O(1)
- 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당
- 장점 : 캐시 히트 가능성이 높으며, 조회가 빠르다.
- 배열의 크기를 미리 지정해야 하는 것이 일반적이므로, 데이터 추가 및 삭제에 한계

# 연결리스트
- 컴퓨터의 메인 메모리 상에서 주소가 연속적이지 않다
- 배열과 다르게 크기가 정해져 있지 않고 리스트의 크기는 동적으로 변경 가능
- 장점 : 포인터를 통해 다음 데이터의 위치를 가리킨다는 점에서 삽입과 삭제가 간편
- 단점 : 특정 번째의 원소를 검색할 때는 앞에서부터 원소를 찾아야하므로, 데이터 검색 속도가 느림

# JS 배열 초기화
- 대괄호 사용(let arr = [];)
- Array 이용(let arr = new Array());
- 변수 외에 객체도 가능
- 임의의 크기를 가지는 배열을 만들 수 있다.
- 원하는 값을 직접 입력하여 초기화 가능
- 크기가 N인 1차원 배열을 만드는 방법
 ㄴ let arr = Array.from({length : 5}, () => 7);
- 2차원 리스트
 ㄴ 직접 값 넣기
   ㄴ let arr = [
     [1,2,3],
     [4,5,6],
     [7,8,9]
   ]
 ㄴ ES6 문법 이용
   ㄴ let arr = Array.from(Array(4), () => new Array(5))
 ㄴ 반복문
   ㄴ let arr = new Array(3);
   for (let i = 0 ; i< arr.length ; i++) {
     arr[i] = Array.from(
     { length : 4 },
     (undefined, j) => i*4+j
     )
   }
- 동적 배열
- 배열이 생성된 이후에도 배열의 크기를 임의로 변경 가능
- push() 메서드를 통해 배열이 가장 뒤에 원소 추가 가능
- concat() : 여러 개의 배열을 이어 붙여서 합친 결과를 반환 (O(N))
  ㄴ let arr1 = [1,2,3]
     let arr2 = [4,5,6]
     let arr = arr1.concat(arr2, [7,8] , [9]);
   => [1,2,3,4,5,6,7,8,9]
- slice(left, right) : 특정 구간의 원소를 꺼낸 배열을 반환(O(N))
  ㄴ let arr = [1,2,3,4,5]
     let result = arr.slice(2,4)
   => [3,4]
- indexOf() : 특정한 값을 가지는 원소의 첫째 인덱스를 반환(O(N))
  ㄴ 해당하는 원소 없으면 -1 반환
  ㄴ let arr = [7,3,5,6,6,2,1]
     console.log(arr.indexOf(5)) => 2
     console.log(arr.indexOf(8)) => -1

# 연결리스트
- 각 노드가 한 줄로 연결되어 있는 자료구조
- 각 노드는 (데이터, 포인터) 형태를 가진다
- 포인터 : 다음 노드의 메모리 주소를 가짐.
- 연결성 : 각 노드의 포인터는 다음 혹은 이전 노드를 가르킴.
- 스택, 큐를 구현가능

# 연결리스트 vs 배열
- 특정 위치의 데이터를 삭제할 떄 배열은 O(N) 만큼 시간 소요
- 연결리스트는 단순히 연결만 끊음 -> 삭제할 위치 아는 경우 O(1) 시간 소요

# 스택
- 먼저 들어온 데이터가 나중에 나가는 자료구조
- 박스가 쌓인 형태
- 선입선출 - 새로운 원소가 마지막 위치에 삽입, 삭제도 마지막 원소 삭제
- Push : 삽입 , O(1)
- Pop : 추출 , O(1)
- Top : 최상위 원소(마지막 원소) 확인 , O(1)
- Empty : 스택이 비어있는지 확인 , O(1)

# JS에서 스택 이용
- 배열 자료형이용
- push() : 삽입
- pop() : 추출
- reverse() : 배열 뒤집기 = 최상단 원소 출력

# 연결 리스트로 스택 구현
- 스택을 연결리스트로 구현시 삽입 삭제에 O(1) 보장
- 머리를 가리키는 하나의 포인터만 가진다.
- 머리 : 남아있는 원소 중 가장 마지막에 들어 온 데이터를 가리키는 포인터

# 큐
- 먼저 삽입된 데이터가 먼저 추출되는 자료구조
- 선입후출 - 새로운 원소가 마지막 위치에 삽입, 삭제는 먼저 들어온 원소 삭제

# 큐를 연결리스트로 구현
- 삽입과 삭제에 있어 O(1)을 보장
- 연결 리스트로 구현 시 머리,꼬리 두개의 포인터 가짐
- 머리 : 가장 머저 들어온 데이터를 가리키는 포인터
- 꼬리 : 가장 마지막에 들어 온 데이터를 가리키는 포인터
- 삽입 : 꼬리 위치에 데이터 넣기
- 삭제 : 머리 위치 데이터 꺼내기
- JS 에서는 Dictionary 자료형을 이용하여 큐 구현

# 트리
- 계층적인 구조를 표현할 때 사용할 수 있는 자료구조
- 루트 노드 : 부모가 없는 최상위 노드
- 단말 노드 : 자식이 없는 노드
- 부모 노드, 자식노드
- 형제 노드 : 같은 부모를 가진 노드들
- 깊이 : 루트 노드에서의 길이(출발 노드에서 목적지까지 거쳐야 하는 간선의 수)
- 트리의 높이는 루트 노드에서 가장 깊은 노드까지의 길이

# 이진 트리
- 최대 2개의 자식을 가지는 트리

# 포화 이진트리
- 리프노드를 제외한 모든 노드가 자식을 두 개 가진 트리

# 완전 이진트리
- 모든 노드가 왼쪽 자식부터 차근차근 채워진 트리

# 높이 균형 트리
- 왼쪽 자식 트리와 오른쪽 자식 트리의 높이가 1이상 차이 나지않는 트리

# 우선순위 큐
- 우선순위에 따라서 데이터를 추출하는 자료구조
- 힙을 이용해 구현
- 가장 우선순위 높은 데이터 추출
- 리스트 자료형으로 구현
  ㄴ 삽입 시간 : O(1)
  ㄴ 삭제 시간 : O(N)
- 힙 자료형으로 구현
  ㄴ 삽입 시간 : O(logN)
  ㄴ 삭제 시간 : O(logN)
- 이진 트리 구조를 사용하는 것이 일반적

# 힙
- 원소들 중에서 최댓값, 최솟값을 빠르게 찾아내는 자료구조
- 완전 이진 트리 자료구조
- 우선 순위가 높은 노드가 루트에 위치
- 최대 힙 : 값이 큰 원소부터 추출
- 최소 힙 : 값이 작은 원소부터 추출
- 삽입, 삭제 O(logN) 시간 요구
- N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일 O(NlogN)

# 최대 힙
- 부모 노드가 자식 노드보다 값이 큰 완전 이진 트리
- 루트 노드는 가장 크고, 큰 데이터가 우선 순위

# 최소 힙
- 부모 노드의 키 값이 식 노드보다 항상 작음
- 루트 노드가 가장 작고, 작은 데이터가 우선순위

# Heapify : 최소 힙 구성 함수
- (상향식)부모로 거슬러 올라가며, 부모보다 자신이 더 작은 경우 위치 교체
- O(logN)의 시간 복잡도로 힙 성질을 유지

# 삽입시 : heapify() 진행

# 힙 삭제시
-> 가장 마지막 노드가 루트 노드의 위치에 오도록 한다
-> 루트 노드에서부터 하향식(더 작은 자식 노드로) heapify 진행

# js 힙 라이브러리 사용

# 그래프
- 사물을 정점(vertex)과 간선(edge)으로 나타내기 위한 도구
- 두가지 방식으로 구현
1. 인접행렬 : 2차원 배열을 사용하는 방식
2. 인접리스트 : 연결 리스트를 이용하는 방식

# 인접 행렬
- 그래프를 2차원 배열로 표현
- 행 시작노드, 열 도착노드
- 모든 정점들의 연결 여부를 저장해 O(V^2)의 공간을요구
  ㄴ 공간 효율성이 떨어지지만, 두 노드의 연결 여부를 O(1)에 확인 가능

# 무방향 무가중치 그래프
- 무방향 그래프 : 모든 간선이 방향성을 가지지 않는 그래프
- 무가중치 그래프 : 모든 간선에 가중치가 없는 그래프
- 무방향 비가중치 그래프가 주어졌을 때 연결되어 있는 상황을 인접행렬로 출력 가능

# 방향 가중치 그래프
- 방향 그래프 : 모든 간선이 방향을 가지는 그래프
- 가중치 그래프 : 모든 간선에 가중치가 있는 그래프
- 방향 가중치 그래프가 주어졌을 때 연결되어 있는 상황을 인접행렬로 출력 가능

# 인접 리스트
- 그래프를 리스트로 표현
- 무방향 무가중치 그래프도 인접 리스트로 출력 가능
- 방향 가중치 그래프도 인접 리스트로 출력 가능
- 연결된 간선의 정보만을 저장하여 O(V+E)의 공간을 요구
  ㄴ 공간 효율성이 우수하지만, 두 노드의 연결 여부를 O(V)의 시간이 필요
- 최단 경로 알고리즘 구현 시 유용
