# 선택 정렬
- 매 단계에서 가장 작은 원소를 선택해서 앞으로 보내는 정렬 방법
- 앞으로 보내진 원소는 더이상 위치가 변경되지 않는다
- O(N^2)으로 비효율적인 정렬 알고리즘

## 선택 정렬 동작 방식
- 각 단계에서 가장 작은 원소 선택
- 처리되지 않은 원소들 중 가장 앞의 원소와 위치를 교체

# 버블 정렬
- 단순히 인접한 두 원소를 확인하여, 정렬이 안되어 있다면 위치를 서로 변경
- O(N^2)으로 비효율적인 정렬 알고리즘

## 버블 정렬 동작 방식
- 각 단계에서는 인접한 두 개의 원소를 비교하여, 필요시 위치 변경
- 첫째와 둘째 비교, 둘째와 셋째 비교, 셋째와 넷째비교
- 한 번의 단계가 수행되면, 가장 큰 원소가 맨뒤로 이동
- 그 다음 단계에서는 맨 뒤로 이동한 데이터는 정렬에서 제외
- 각 단계를 거칠 때마다 가장 큰 값을 하나씩 확실하게 결정하는 것

# 삽입 정렬
- 각 단계에서 현재 원소가 삽입될 위치를 찾음
- 적절한 위치 도달할 때 까지 반복적으로 왼쪽으로 이동
- O(N^2)으로 비효율적인 정렬 알고리즘

# 분할 정복
- 분할 : 큰 문제를 작은 부분 문제로 분할
- 정복 : 작은 부분 문제를 각각 해결
- 조합 : 해결한 부분 문제의 답을 이용하여 다시 큰 문제를 해결
- 분할 정복은 일반적으로 재귀 함수를 이용하여 구현
- 큰 문제를 작은 문제로 분할하는 방식이 동일한 경우가 많기 때문
- 더 이상 쪼갤 수 없는 크기가 될 때까지 계속하여 분할
- 재귀 함수를 사용한다는 점에서 함수 호출 횟수가 많이 발생
- 오버헤드로 이어질수 있음.

# 병합 정렬
- 전형적인 분할 정복 알고리즘
- 분할 : 정렬할 배열(큰 문제)을 같은 크기의 부분 배열(작은 문제) 2개로 분할
  ㄴ 단순히 배열의 크기를 절반으로 쪼개는 것
- 정복 : 부분 배열을 정렬 (작은 문제 해결)
  ㄴ 두 개의 부분 배열을 정렬된 하나의 배열로 만듦
  ㄴ 각 부분 배열은 이미 정렬된 상태
  ㄴ 각 부분 배열에 대하여 첫째 원소부터 시작하여 하나씩 확인
  ㄴ 총 원소의 개수가 N개 일 때, O(N)의 시간 복잡도가 요구
- 조합 : 정렬된 부분 배열을 하나의 배열로 다시 병합
- O(NlogN), 빠른 정렬 알고리즘 중 하나

## 시간복잡도
- 직관적으로, 높이가 O(logN), 너비가 O(N)인 정사각형과 유사
- 최악의 경우 O(NlogN)
- 장점 : 최악의 경우에도 O(Nlogn)을 보장
- 단점 : 정복 과정에서 임시 배열이 필요

# JS 정렬 라이브러리
- sort() : 배열에 포함된 데이터를 정렬
- O(NlogN)을 보장
- sort가 제한된다면, 병합 정렬과 같은 알고리즘 직접 구현 사용

## JS 정렬 기준 함수
- 반환 값이 0보다 작은 경우 -> a가 우선 순위가 높아 앞에 위치
- 반환 값이 0보다 큰 경우 -> b가 우선 순위가 높아 앞에 위치
- 반환 값이 0인 경우 -> a와 b의 순서를 변경하지 않는다.
- 정렬 기준 함수를 사용하지 않으면 각 원소는 문자열로 취급
- 유니코드 값 순서대로 정렬
-> 정렬 기준 함수를 명시하는 습관이 필요
